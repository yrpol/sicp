#lang racket

(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))

// В данном случае производится проверка на использование оператором нормального или аппликативного порядка вычислений. В нормальном порядке сначала вычисляются все выражения, а уже потом подставляются и вычисляются операнды. В аппликативном порядке вычислений наоборот сначала вычисляются операнды, а уже потом они подставляются в выражения. 

// В этом тесте сначала определяется функция p, через саму себя. То есть, запуск этой функции приведет к бесконечному циклу. Если используется нормальный порядок, то так и произойдет, так как интерпретатор сначала будет вычислять все процедуры. Если же используется аппликативный порядок действий, то сначала будет вычислено выражение, согласно которому x = 0, а значит сработает первое условие if’a, то есть, вернется 0 и до вычисления p программа не дойдет.
 
